/* Do not edit, autogenerated by pscript */

var _pyfunc_op_equals = function op_equals (a, b) { // nargs: 2
    var a_type = typeof a;
    // If a (or b actually) is of type string, number or boolean, we don't need
    // to do all the other type checking below.
    if (a_type === "string" || a_type === "boolean" || a_type === "number") {
        return a == b;
    }

    if (a == null || b == null) {
    } else if (Array.isArray(a) && Array.isArray(b)) {
        var i = 0, iseq = a.length == b.length;
        while (iseq && i < a.length) {iseq = op_equals(a[i], b[i]); i+=1;}
        return iseq;
    } else if (a.constructor === Object && b.constructor === Object) {
        var akeys = Object.keys(a), bkeys = Object.keys(b);
        akeys.sort(); bkeys.sort();
        var i=0, k, iseq = op_equals(akeys, bkeys);
        while (iseq && i < akeys.length)
            {k=akeys[i]; iseq = op_equals(a[k], b[k]); i+=1;}
        return iseq;
    } return a == b;
};
var _pyfunc_truthy = function (v) {
    if (v === null || typeof v !== "object") {return v;}
    else if (v.length !== undefined) {return v.length ? v : false;}
    else if (v.byteLength !== undefined) {return v.byteLength ? v : false;}
    else if (v.constructor !== Object) {return true;}
    else {return Object.getOwnPropertyNames(v).length ? v : false;}
};
var _pymeth_append = function (x) { // nargs: 1
    if (!Array.isArray(this)) return this.append.apply(this, arguments);
    this.push(x);
};
var eDep, onestatus, src, src_statuses, srcs, stsupdate, updatets;
src = function (si) {return srcs[si];};
srcs = ({});
eDep = ({});
stsupdate = function flx_stsupdate (Si, Dh) {
    var e, stub1_seq, stub2_itr;
    console.log(Si + " ");
    stub1_seq = (function list_comprehension (iter0) {var res = [];var e, i0;if ((typeof iter0 === "object") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {e = iter0[i0];if (!(_pyfunc_op_equals(e.si, Si))) {continue;}{res.push(e);}}return res;}).call(this, eDep);
    if ((typeof stub1_seq === "object") && (!Array.isArray(stub1_seq))) { stub1_seq = Object.keys(stub1_seq);}
    for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {
        e = stub1_seq[stub2_itr];
        e.rtset();
    }
    (src(Si).sdhset)(Dh);
    return null;
};

onestatus = function flx_onestatus (Si) {
    var Dh, changed, stub3_, tr;
    tr = (src(Si).sdhck)();
    if ((tr !== null)) {
        stub3_ = tr;
        Dh = stub3_[0];changed = stub3_[1];
        if (_pyfunc_truthy(changed)) {
            stsupdate(Si, Dh);
            console.log("");
        }
    }
    return null;
};

src_statuses = function flx_src_statuses () {
    var Dh, SDl, Si, changed, stub4_, stub5_seq, stub6_itr, tr;
    SDl = [];
    stub5_seq = srcs;
    if ((typeof stub5_seq === "object") && (!Array.isArray(stub5_seq))) { stub5_seq = Object.keys(stub5_seq);}
    for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {
        Si = stub5_seq[stub6_itr];
        tr = (src(Si).sdhck)();
        if ((tr !== null)) {
            stub4_ = tr;
            Dh = stub4_[0];changed = stub4_[1];
            if (_pyfunc_truthy(changed)) {
                _pymeth_append.call(SDl, [Si, Dh]);
            }
        }
    }
    return SDl;
};

updatets = function flx_updatets (N) {
    var Dh, Si, Sl, stub7_seq, stub8_itr, stub9_tgt;
    console.log("Status" + " " + N);
    Sl = src_statuses();
    if (Sl.length) {
        console.log("changed: " + "");
        stub7_seq = Sl;
        if ((typeof stub7_seq === "object") && (!Array.isArray(stub7_seq))) { stub7_seq = Object.keys(stub7_seq);}
        for (stub8_itr = 0; stub8_itr < stub7_seq.length; stub8_itr += 1) {
            stub9_tgt = stub7_seq[stub8_itr];
            Si = stub9_tgt[0]; Dh = stub9_tgt[1];
            stsupdate(Si, Dh);
        }
        console.log("");
    }
    return null;
};
